// src/pages/CustomFlowChartEditor.jsx
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import { useParams } from 'react-router-dom';
import "../css/main.css";
import "../css/custom-communication.css";
// é è¨­å°ºå¯¸èˆ‡æ‰‹æŠŠå¤§å°
const NODE_WIDTH_DEFAULT = 140;
const NODE_HEIGHT_DEFAULT = 80;
const RESIZE_HANDLE_SIZE = 8;

// å®šç¾©å…è¨±çš„çˆ¶ç¯€é»èˆ‡å­ç¯€é»é¡å‹
const allowedChildren = {
  phase: ["task", "phase", "subFlow", "iterative", "note", "extra"],
  task: ["subFlow", "iterative", "note", "extra"],
};

// æ ¹æ“šç¯€é»ç‹€æ…‹è¨­å®šèƒŒæ™¯é¡è‰²ï¼ˆé è¨­ï¼‰
const getStatusColor = (node) => {
  const statusColors = {
    "å·²å®Œæˆ": "#d4edda",
    "é€²è¡Œä¸­": "#cce5ff",
    "è¦åŠƒä¸­": "#fff3cd",
    "æœªé–‹å§‹": "#e2e3e5",
    "è‡ªè¨‚": "#f8d7da"
  };
  if (node.type === "phase" || node.type === "task") {
    return statusColors[node.status] || statusColors["æœªé–‹å§‹"];
  }
  return "#fff";
};
// æ¸²æŸ“ç®­é ­å‡½æ•¸
const renderArrow = (node) => {
  const { points } = node;
  if (!points || points.length < 2) return null;
  
  // å°‡æ‰€æœ‰é»é€£æ¥ç‚ºSVGè·¯å¾‘
  let pathData = `M ${points[0].x} ${points[0].y}`;
  for (let i = 1; i < points.length; i++) {
    pathData += ` L ${points[i].x} ${points[i].y}`;
  }
  
  // è¨ˆç®—ç®­é ­æ–¹å‘ (æœ€å¾Œå…©å€‹é»æ±ºå®š)
  const lastPoint = points[points.length - 1];
  const prevPoint = points[points.length - 2];
  const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x);
  
  // ç®­é ­å°–ç«¯
  const arrowLength = 10;
  const arrowAngle = Math.PI / 6; // 30åº¦
  const x1 = lastPoint.x - arrowLength * Math.cos(angle - arrowAngle);
  const y1 = lastPoint.y - arrowLength * Math.sin(angle - arrowAngle);
  const x2 = lastPoint.x - arrowLength * Math.cos(angle + arrowAngle);
  const y2 = lastPoint.y - arrowLength * Math.sin(angle + arrowAngle);
  
  return (
    <svg width="100%" height="100%" style={{ position: 'absolute', top: 0, left: 0, pointerEvents: 'none' }}>
      <path d={pathData} stroke="black" strokeWidth="2" fill="none" />
      <path d={`M ${lastPoint.x} ${lastPoint.y} L ${x1} ${y1} L ${x2} ${y2} Z`} fill="black" />
    </svg>
  );
};
// æ ¹æ“šå½¢ç‹€è¨­å®šé¡å¤– CSS
const getShapeStyle = (shape) => {
  switch (shape) {
    case 'ellipse':
      return { borderRadius: "50px" };
    case 'parallelogram':
      return { transform: "skew(-20deg)" };
    case 'diamond':
      return { transform: "rotate(45deg)" };
    case 'rectangle':
    default:
      return {};
  }
};

// æ ¹æ“š type æ¸²æŸ“ç¯€é»å…§å®¹èˆ‡æ¨£å¼
const renderNodeContent = (node) => {
  const commonStyle = { padding: "4px", textAlign: "center", overflow: "hidden", width: "100%", height: "100%" };
  const statusText = (node.type === "phase" || node.type === "task")
    ? `Status: ${node.status}${node.status === "è‡ªè¨‚" && node.customStatus ? ` (${node.customStatus})` : ""}`
    : "";
  switch (node.type) {
    case "phase":
      return (
        <div style={{ ...commonStyle }}>
          <div style={{ fontWeight: "bold", fontSize: "14px" }}>{node.label}</div>
          <div style={{ fontSize: "12px" }}>{node.description}</div>
          <div style={{ fontSize: "10px", marginTop: "4px" }}>{statusText}</div>
        </div>
      );
    case "task":
      return (
        <div style={{ ...commonStyle }}>
          <div style={{ fontWeight: "bold", fontSize: "14px" }}>{node.label}</div>
          {node.important && <div style={{ color: "red", fontSize: "10px" }}>Important</div>}
          <div style={{ fontSize: "12px" }}>{node.description}</div>
          <div style={{ fontSize: "10px", marginTop: "4px" }}>{statusText}</div>
        </div>
      );
    case "subFlow":
      return (
        <div style={{ ...commonStyle, border: "2px solid gray", backgroundColor: "#f0f0f0" }}>
          <div style={{ fontWeight: "bold", fontSize: "13px" }}>{node.label}</div>
          <div style={{ fontSize: "11px" }}>{node.description}</div>
        </div>
      );
    case "iterative":
      return (
        <div style={{ ...commonStyle, border: "2px dotted green", backgroundColor: "#e8ffe8" }}>
          <div style={{ fontWeight: "bold", fontSize: "14px" }}>{node.label} ğŸ”„</div>
          <div style={{ fontSize: "12px" }}>{node.description}</div>
        </div>
      );
    case "note":
      return (
        <div style={{ ...commonStyle, border: "1px solid orange", backgroundColor: "#fff7d6" }}>
          <div style={{ fontStyle: "italic", fontSize: "12px" }}>{node.text || node.label}</div>
          <div style={{ fontSize: "10px" }}>{node.description}</div>
        </div>
      );
    case "extra":
      return (
        <div style={{ ...commonStyle, fontSize:"10px", padding: "2px" }}>
          â€¢ {node.content}
        </div>
      );
    default:
      return (
        <div style={{ ...commonStyle, border: "1px solid black" }}>
          {node.label || "No Label"}
        </div>
      );
  }
};

// è¼”åŠ©å‡½å¼ï¼šåˆ¤æ–·æ˜¯å¦ç‚ºæ‹–æ›³ç¯€é»çš„å¾Œä»£ï¼ˆæ ¹æ“š containerId éè¿´æª¢æŸ¥ï¼‰
const isDescendant = (draggedId, node, allNodes) => {
  if (node.containerId === draggedId) return true;
  if (!node.containerId) return false;
  const parent = allNodes.find(n => n.id === node.containerId);
  if (!parent) return false;
  return isDescendant(draggedId, parent, allNodes);
};

const CustomFlowChartEditor = () => {
  const { id } = useParams();
  const isTemplateMode = id.startsWith("template_");
  const realId = isTemplateMode ? id.split("_")[1] : id;
  const token = localStorage.getItem('token');
  const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5001/api';
  const containerRef = useRef(null);

  // å–å¾—è§’è‰² (å‡è¨­ token payload åŒ…å« role)
  const getRole = () => {
    if (token) {
      try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        return payload.role || null;
      } catch (error) {
        console.error("Token decoding error:", error);
      }
    }
    return null;
  };
  const role = getRole();
  // è‹¥è§’è‰²ç‚º customerï¼Œå‰‡ç‚ºå”¯è®€æ¨¡å¼
  const isReadOnly = role === "customer";

  // ç¯€é»è³‡æ–™
  const [nodes, setNodes] = useState([]);
  const [selectedNodeId, setSelectedNodeId] = useState(null);
  const [draggingNodeId, setDraggingNodeId] = useState(null);
  const [resizingNodeId, setResizingNodeId] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [resizeStart, setResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 });
  // æ–°å¢é¡¯ç¤ºæ¨¡å¼ï¼šflowchart æˆ– list
  const [displayMode, setDisplayMode] = useState("flowchart");
  // ç”¨ä¾†å„²å­˜æ¯å€‹ Phase æ˜¯å¦æ‘ºç–Šçš„ç‹€æ…‹
  const [collapsedPhases, setCollapsedPhases] = useState({});

  // è®€å–æµç¨‹åœ–è³‡æ–™
  useEffect(() => {
    const fetchData = async () => {
      try {
        const url = isTemplateMode
          ? `${API_URL}/templates/${realId}`
          : `${API_URL}/projects/${realId}/flowchart`;
        const res = await axios.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        });
        const data = isTemplateMode ? (res.data.flowChart || []) : (res.data || []);
        const mapped = data.map(item => ({
          ...item,
          position: item.position || { x: 50, y: 50 },
          size: item.size || { width: NODE_WIDTH_DEFAULT, height: NODE_HEIGHT_DEFAULT },
          containerId: item.containerId || null,
          children: item.children || [],
          status: (item.type === "phase" || item.type === "task") ? (item.status || "æœªé–‹å§‹") : item.status,
          shape: (item.type === "phase" || item.type === "task") ? (item.shape || "rectangle") : item.shape,
          // æ–°å¢é¡¯ç¤ºæ§åˆ¶å±¬æ€§ï¼Œé è¨­ true
          showInFlowchart: item.showInFlowchart !== false,
          showForCustomer: item.showForCustomer !== false
        }));
        setNodes(mapped);
      } catch (error) {
        console.error("Failed to load flowchart:", error);
      }
    };
    fetchData();
  }, [realId, isTemplateMode, API_URL, token]);

  const selectedNode = nodes.find(n => n.id === selectedNodeId);

  // æ›´æ–°é¸ä¸­ç¯€é»å±¬æ€§
  const handleEditChange = (e) => {
    if (!selectedNodeId) return;
    const { name, value } = e.target;
    setNodes(prevNodes =>
      prevNodes.map(n =>
        n.id === selectedNodeId ? { ...n, [name]: value } : n
      )
    );
  };

// æ–°å¢ç®­é ­æ§åˆ¶é»
const handleAddControlPoint = (nodeId) => {
  if (isReadOnly) return;
  
  setNodes(prevNodes => 
    prevNodes.map(n => {
      if (n.id === nodeId && n.type === "arrow") {
        // è¨ˆç®—æ–°æ§åˆ¶é»çš„ä½ç½® (åœ¨æœ€å¾Œä¸€é»å’Œå€’æ•¸ç¬¬äºŒé»ä¹‹é–“)
        const points = [...n.points];
        const lastIdx = points.length - 1;
        const newPoint = {
          x: (points[lastIdx].x + points[lastIdx-1].x) / 2,
          y: (points[lastIdx].y + points[lastIdx-1].y) / 2
        };
        
        // åœ¨å€’æ•¸ç¬¬äºŒé»ä¹‹å¾Œæ’å…¥æ–°é»
        points.splice(lastIdx, 0, newPoint);
        
        return { ...n, points };
      }
      return n;
    })
  );
};

// åˆªé™¤ç®­é ­æ§åˆ¶é»
const handleDeleteControlPoint = (nodeId, pointIndex) => {
  if (isReadOnly) return;
  
  setNodes(prevNodes => 
    prevNodes.map(n => {
      if (n.id === nodeId && n.type === "arrow") {
        // ä¿è­‰è‡³å°‘ä¿ç•™å…©å€‹æ§åˆ¶é»
        if (n.points.length <= 2) return n;
        
        // ä¸å…è¨±åˆªé™¤é¦–å°¾æ§åˆ¶é»
        if (pointIndex === 0 || pointIndex === n.points.length - 1) return n;
        
        const newPoints = n.points.filter((_, idx) => idx !== pointIndex);
        return { ...n, points: newPoints };
      }
      return n;
    })
  );
};

  // è™•ç† children æ¬„ä½ï¼ˆé€—è™Ÿåˆ†éš”è½‰é™£åˆ—ï¼‰
  const handleChildrenChange = (e) => {
    if (!selectedNodeId) return;
    const children = e.target.value.split(",").map(s => s.trim()).filter(s => s);
    setNodes(prevNodes =>
      prevNodes.map(n =>
        n.id === selectedNodeId ? { ...n, children } : n
      )
    );
  };

  // åˆ‡æ›æ ¸å–æ–¹å¡Šï¼Œè¨­å®šç¯€é»æ˜¯å¦åœ¨æµç¨‹åœ–ä¸­é¡¯ç¤º
  const handleToggleShow = (nodeId, value) => {
    setNodes(prevNodes =>
      prevNodes.map(n => n.id === nodeId ? { ...n, showInFlowchart: value } : n)
    );
  };

  // åˆ‡æ› Phase æ‘ºç–Šç‹€æ…‹
  const toggleCollapse = (phaseId) => {
    setCollapsedPhases(prev => ({
      ...prev,
      [phaseId]: !prev[phaseId]
    }));
  };

  // è‹¥ç‚ºå”¯è®€æ¨¡å¼ï¼Œå‰‡ä¸åŸ·è¡Œæ‹–æ›³èˆ‡ç¸®æ”¾æ“ä½œ
  const handleMouseDown = (e, nodeId) => {
    if (isReadOnly) return;
    e.stopPropagation();
    const nodeElem = e.currentTarget;
    const rect = nodeElem.getBoundingClientRect();
    setDraggingNodeId(nodeId);
    setDragOffset({ x: e.clientX - rect.left, y: e.clientY - rect.top });
  };

  const handleMouseMove = (e) => {
    if (isReadOnly) return;
    if (draggingNodeId) {
      setNodes(prevNodes => {
        const draggedNode = prevNodes.find(n => n.id === draggingNodeId);
        if (!draggedNode) return prevNodes;
        const containerRect = containerRef.current.getBoundingClientRect();
        const newX = e.clientX - containerRect.left - dragOffset.x;
        const newY = e.clientY - containerRect.top - dragOffset.y;
        const deltaX = newX - draggedNode.position.x;
        const deltaY = newY - draggedNode.position.y;
        return prevNodes.map(n => {
          if (n.id === draggingNodeId || isDescendant(draggingNodeId, n, prevNodes)) {
            return {
              ...n,
              position: {
                x: n.position.x + deltaX,
                y: n.position.y + deltaY
              }
            };
          }
          return n;
        });
      });
    }
    if (resizingNodeId) {
      const containerRect = containerRef.current.getBoundingClientRect();
      const dx = e.clientX - containerRect.left - resizeStart.x;
      const dy = e.clientY - containerRect.top - resizeStart.y;
      setNodes(prevNodes =>
        prevNodes.map(n => {
          if (n.id === resizingNodeId) {
            return {
              ...n,
              size: {
                width: Math.max(40, resizeStart.width + dx),
                height: Math.max(30, resizeStart.height + dy)
              }
            };
          }
          return n;
        })
      );
    }
  };

  const handleMouseUp = () => {
    if (isReadOnly) return;
    if (draggingNodeId) {
      setNodes(prevNodes => {
        const draggedNode = prevNodes.find(n => n.id === draggingNodeId);
        let newContainerId = draggedNode ? draggedNode.containerId : null; // ä¿æŒåŸæœ‰çš„çˆ¶èŠ‚ç‚¹
        
        // é¿å…å¾ªç’°åƒç…§ï¼šæª¢æŸ¥æ˜¯å¦å°‡ç¯€é»æ‹–å…¥å…¶å­ç¯€é»å…§
        const isCircularReference = (parentId, childId) => {
          // å¦‚æœçˆ¶ç¯€é»IDç­‰æ–¼å­ç¯€é»IDï¼Œé€™æ˜¯å¾ªç’°åƒç…§
          if (parentId === childId) return true;
          
          // å–å¾—å­ç¯€é»çš„æ‰€æœ‰å­ç¯€é»ID
          const child = prevNodes.find(n => n.id === childId);
          if (!child || !child.children || child.children.length === 0) return false;
          
          // å°æ¯å€‹å­ç¯€é»çš„å­ç¯€é»éè¿´æª¢æŸ¥
          return child.children.some(grandChildId => 
            isCircularReference(parentId, grandChildId)
          );
        };
        
        if (draggedNode) {
          const center = {
            x: draggedNode.position.x + draggedNode.size.width / 2,
            y: draggedNode.position.y + draggedNode.size.height / 2
          };
          
          // æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„å®¹å™¨ç¯€é»ï¼Œä¸¦æŒ‰ç…§ z-index æ’åºï¼ˆè¼ƒé«˜çš„ z-index å„ªå…ˆï¼‰
          const potentialContainers = prevNodes
            .filter(parent => 
              parent.id !== draggedNode.id && 
              (parent.type === "phase" || parent.type === "task") &&
              center.x >= parent.position.x &&
              center.x <= parent.position.x + parent.size.width &&
              center.y >= parent.position.y &&
              center.y <= parent.position.y + parent.size.height
            )
            .sort((a, b) => {
              // è¨ˆç®— z-index: æ ¹æ“š containerId çš„å­˜åœ¨ä¾†åˆ¤æ–·å±¤ç´š
              const getDepth = (node) => {
                if (!node.containerId) return 0;
                const parent = prevNodes.find(n => n.id === node.containerId);
                return parent ? 1 + getDepth(parent) : 1;
              };
              
              return getDepth(b) - getDepth(a); // è¼ƒæ·±å±¤ç´šçš„å®¹å™¨å„ªå…ˆé¸æ“‡
            });
          
          // é¸æ“‡ç¬¬ä¸€å€‹åˆé©çš„å®¹å™¨ä½œç‚ºæ–°çš„çˆ¶ç¯€é»
          for (const parent of potentialContainers) {
            const allowed = allowedChildren[parent.type] || [];
            // æª¢æŸ¥æ˜¯å¦å…è¨±æ­¤é¡å‹çš„å­ç¯€é»ï¼Œä¸”ä¸æœƒé€ æˆå¾ªç’°åƒç…§
            if (allowed.includes(draggedNode.type) && !isCircularReference(draggedNode.id, parent.id)) {
              newContainerId = parent.id;
              break;
            }
          }
        }
        
        return prevNodes.map(n => {
          if (n.id === draggingNodeId) {
            return { ...n, containerId: newContainerId };
          }
          // æ›´æ–°æ‰€æœ‰å¯èƒ½çš„çˆ¶ç¯€é»çš„childrenå±¬æ€§
          if (n.type === "phase" || n.type === "task") {
            let newChildren = n.children ? [...n.children] : [];
            // å…ˆå¾æ‰€æœ‰ç¯€é»çš„childrenä¸­ç§»é™¤æ‹–æ›³çš„ç¯€é»
            newChildren = newChildren.filter(childId => childId !== draggingNodeId);
            // å¦‚æœæ­¤ç¯€é»æ˜¯æ–°çš„çˆ¶ç¯€é»ï¼Œå‰‡æ·»åŠ æ‹–æ›³çš„ç¯€é»åˆ°å…¶children
            if (n.id === newContainerId) {
              newChildren.push(draggingNodeId);
            }
            return { ...n, children: newChildren };
          }
          return n;
        });
      });
      setDraggingNodeId(null);
    }
    if (resizingNodeId) {
      setResizingNodeId(null);
    }
  };

  // ç¯€é»é¸å–ï¼ˆå”¯è®€æ¨¡å¼ä¹Ÿå¯é»é¸æŸ¥çœ‹è³‡è¨Šï¼‰
  const handleSelectNode = (e, nodeId) => {
    e.stopPropagation();
    setSelectedNodeId(nodeId);
  };

  // é–‹å§‹ç¸®æ”¾
  const handleResizeMouseDown = (e, nodeId) => {
    if (isReadOnly) return;
    e.stopPropagation();
    if (!selectedNode) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    setResizingNodeId(nodeId);
    setResizeStart({
      x: e.clientX - containerRect.left,
      y: e.clientY - containerRect.top,
      width: selectedNode.size.width,
      height: selectedNode.size.height
    });
  };

  // åˆªé™¤ç¯€é»ï¼ˆå”¯è®€æ¨¡å¼ä¸å¯æ“ä½œï¼‰
  const handleDeleteNode = () => {
    if (isReadOnly || !selectedNodeId) return;
    setNodes(prevNodes =>
      prevNodes.filter(n => n.id !== selectedNodeId)
        .map(n => n.containerId === selectedNodeId ? { ...n, containerId: null } : n)
    );
    setSelectedNodeId(null);
  };

  // æ–°å¢ç¯€é»ï¼ˆå”¯è®€æ¨¡å¼ä¸å¯æ“ä½œï¼‰
  const handleAddNewNode = (type = "task") => {
    if (isReadOnly) return;
    let newNode = null;
    // æ–°å¢ç¯€é»å‡½æ•¸ä¸­çš„ç®­é ­éƒ¨åˆ†
if (type === "arrow") {
  // é è¨­ç®­é ­çš„å¯¬é«˜èˆ‡æ§åˆ¶é»ï¼ˆpoints ç‚ºç›¸å°æ–¼ç®­é ­å€å¡Šçš„åº§æ¨™ï¼‰
  newNode = {
    id: `arrow_${Date.now()}`,
    type: "arrow",
    label: "Arrow",
    points: [
      { x: 10, y: NODE_HEIGHT_DEFAULT / 2 },
      { x: NODE_WIDTH_DEFAULT - 10, y: NODE_HEIGHT_DEFAULT / 2 }
    ],
    position: { x: 100, y: 100 },
    size: { width: NODE_WIDTH_DEFAULT, height: NODE_HEIGHT_DEFAULT },
    showInFlowchart: true
  };

    } else {
      newNode = {
        id: `${Date.now()}`,
        type,
        label: type === "phase" ? "New Phase" : "New Node",
        description: "",
        link: "",
        extras: [],
        children: [],
        containerId: null,
        position: { x: 50, y: 50 },
        size: { width: NODE_WIDTH_DEFAULT, height: NODE_HEIGHT_DEFAULT },
        status: (type === "phase" || type === "task") ? "æœªé–‹å§‹" : "",
        shape: (type === "phase" || type === "task") ? "rectangle" : "",
        showInFlowchart: true
      };
    }
    setNodes(prev => [...prev, newNode]);
  };

// 2. æ–°å¢ç‹€æ…‹ç”¨æ–¼æ‹–æ›³ç®­é ­çš„æ§åˆ¶é»
const [draggingControlPoint, setDraggingControlPoint] = useState(null);

// è™•ç†æ‹–æ›³æ§åˆ¶é»
// ä¿®æ”¹æ§åˆ¶é»é¼ æ¨™äº‹ä»¶è™•ç†
const handleControlPointMouseDown = (e, nodeId, pointIndex) => {
  e.stopPropagation();
  
  // å³éµé¡¯ç¤ºèœå–®
  if (e.button === 2) {
    e.preventDefault();
    // ä¸å…è¨±åˆªé™¤é¦–å°¾æ§åˆ¶é»
    if (pointIndex !== 0 && pointIndex !== nodes.find(n => n.id === nodeId).points.length - 1) {
      handleDeleteControlPoint(nodeId, pointIndex);
    }
    return;
  }
  
  // å–å¾— container çš„åç§»é‡ï¼ˆæ–¹ä¾¿è¨ˆç®—ç›¸å°åº§æ¨™ï¼‰
  const containerRect = containerRef.current.getBoundingClientRect();
  setDraggingControlPoint({
    nodeId,
    pointIndex,
    offsetX: e.clientX - containerRect.left,
    offsetY: e.clientY - containerRect.top
  });
};

useEffect(() => {
  const handleControlPointMouseMove = (e) => {
    if (!draggingControlPoint) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    const newX = e.clientX - containerRect.left;
    const newY = e.clientY - containerRect.top;
    const dx = newX - draggingControlPoint.offsetX;
    const dy = newY - draggingControlPoint.offsetY;
    setNodes(prevNodes =>
      prevNodes.map(n => {
        if (n.id === draggingControlPoint.nodeId && n.type === "arrow") {
          // æ›´æ–°æŒ‡å®šæ§åˆ¶é»ï¼Œæ³¨æ„é€™è£¡æ§åˆ¶é»ç‚ºç›¸å°æ–¼ç®­é ­å€å¡Šçš„åº§æ¨™ï¼Œ
          // å‡è¨­ç®­é ­ç¯€é»ä¸æœƒè¢«ç¸®æ”¾ï¼ˆæˆ–ç¸®æ”¾æ™‚ä¹Ÿæ›´æ–° pointsï¼‰
          const newPoints = n.points.map((pt, idx) =>
            idx === draggingControlPoint.pointIndex
              ? { x: pt.x + dx, y: pt.y + dy }
              : pt
          );
          return { ...n, points: newPoints };
        }
        return n;
      })
    );
    // æ›´æ–°æ‹–æ›³èµ·å§‹é»
    setDraggingControlPoint({
      ...draggingControlPoint,
      offsetX: newX,
      offsetY: newY
    });
  };

  const handleControlPointMouseUp = () => {
    setDraggingControlPoint(null);
  };

  window.addEventListener("mousemove", handleControlPointMouseMove);
  window.addEventListener("mouseup", handleControlPointMouseUp);
  return () => {
    window.removeEventListener("mousemove", handleControlPointMouseMove);
    window.removeEventListener("mouseup", handleControlPointMouseUp);
  };
}, [draggingControlPoint]);



  // å„²å­˜æµç¨‹åœ–ï¼ˆå”¯è®€æ¨¡å¼ä¸å¯æ“ä½œï¼‰
  const handleSave = async () => {
    if (isReadOnly) return;
    try {
      const url = isTemplateMode
        ? `${API_URL}/templates/${realId}`
        : `${API_URL}/projects/${realId}/flowchart`;
      await axios.put(url,
        { flowChart: nodes },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      alert("Flowchart saved successfully!");
    } catch (error) {
      console.error("Failed to save flowchart:", error);
      alert("Save failed.");
    }
  };
  useEffect(() => {
    const handleKeyDown = (e) => {
      // å¦‚æœç„¦é»åœ¨ input æˆ– textarea ä¸­ï¼Œå‰‡ä¸è™•ç†å¿«æ·éµ
      const tag = e.target.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA") {
        return;
      }
  
      // Delete éµåˆªé™¤é¸ä¸­çš„ç¯€é»
      if (e.key === "Delete") {
        e.preventDefault();
        handleDeleteNode();
      }
  // Delete éµåˆªé™¤é¸ä¸­çš„ç¯€é»
  if (e.key === "Backspace") {
    e.preventDefault();
    handleDeleteNode();
  }
      // Ctrl+S æˆ– Cmd+S å„²å­˜æµç¨‹åœ–
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        handleSave();
      }
    };
  
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleDeleteNode, handleSave]);
  
  // ä¸‹è¼‰æµç¨‹åœ– JSON
  const handleDownloadFlowchart = () => {
    const templateName = prompt("è«‹è¼¸å…¥æ¨¡æ¿åç¨±ï¼š", `Flowchart Template ${realId}`);
    const exportData = {
      name: templateName,
      flowChart: nodes
    };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
    const a = document.createElement("a");
    a.href = dataStr;
    a.download = `${templateName || "flowchart_template"}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  };

  // ä¸Šå‚³æµç¨‹åœ– JSON
  const handleUploadFlowchart = (e) => {
    if (isReadOnly) return;
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const json = JSON.parse(event.target.result);
        if (json.flowChart) {
          setNodes(json.flowChart);
        } else {
          setNodes(json);
        }
      } catch (error) {
        alert("Invalid JSON file");
      }
    };
    reader.readAsText(file);
  };

  // Header å€å¡Šï¼Œæ ¹æ“šå”¯è®€æ¨¡å¼éš±è—ç·¨è¼¯ç›¸é—œæŒ‰éˆ•
const renderHeader = () => (
  <div className="flowchart-controls">
    {!isReadOnly && (
      <>
        <button onClick={() => setDisplayMode("flowchart")} className={`yuniver-btn ${displayMode === "flowchart" ? "" : "secondary"} yuniver-filter-btn`}>
          Flowchart View
        </button>
        <button onClick={() => setDisplayMode("list")} className={`yuniver-btn ${displayMode === "list" ? "" : "secondary"} yuniver-filter-btn`}>
          List View
        </button>
        <button onClick={() => handleAddNewNode("task")} className="yuniver-btn secondary yuniver-filter-btn">
          Add Task
        </button>
        <button onClick={() => handleAddNewNode("phase")} className="yuniver-btn secondary yuniver-filter-btn">
          Add Phase
        </button>
        <button onClick={() => handleAddNewNode("arrow")} className="yuniver-btn secondary yuniver-filter-btn">
          Add Arrow
        </button>
        <button onClick={handleSave} className="yuniver-btn yuniver-filter-btn">
          Save Flow Chart
        </button>
        <button onClick={handleDownloadFlowchart} className="yuniver-btn secondary yuniver-filter-btn">
          Download Flowchart
        </button>
        <div className="flowchart-import">
          <label className="yuniver-btn secondary">
            Import Flowchart
            <input type="file" accept=".json" onChange={handleUploadFlowchart} style={{ display: "none" }} />
          </label>
        </div>
      </>
    )}
  </div>
);
// ç§»å‹• Phaseï¼šèƒ½è™•ç†å·¢ç‹€ Phase çš„æ’åº
const movePhase = (phaseId, direction) => {
  if (isReadOnly) return;
  setNodes(prevNodes => {
    // æ‰¾åˆ°ç›®æ¨™ Phase
    const targetPhase = prevNodes.find(n => n.id === phaseId);
    if (!targetPhase) return prevNodes;
    
    // ç²å–åŒä¸€å±¤ç´šçš„ Phase ç¯€é»ï¼ˆç›¸åŒçš„çˆ¶ç¯€é»ï¼‰
    const siblingPhases = prevNodes.filter(n => 
      n.type === "phase" && 
      String(n.containerId) === String(targetPhase.containerId)
    );
    
    // æ‰¾å‡ºç›®æ¨™ Phase åœ¨åŒå±¤ç´šä¸­çš„ç´¢å¼•
    const index = siblingPhases.findIndex(p => p.id === phaseId);
    if (index === -1) return prevNodes;
    
    // è¨ˆç®—æ–°ç´¢å¼•
    const newIndex = index + (direction === "up" ? -1 : 1);
    
    // ç¢ºä¿æ–°ç´¢å¼•åœ¨æœ‰æ•ˆç¯„åœå…§
    if (newIndex < 0 || newIndex >= siblingPhases.length) return prevNodes;
    
    // äº¤æ›ç›¸åŒå±¤ç´šçš„å…©å€‹ Phase çš„é †åº
    [siblingPhases[index], siblingPhases[newIndex]] = [siblingPhases[newIndex], siblingPhases[index]];
    
    // æ§‹å»ºæ–°çš„ nodes é™£åˆ—
    return prevNodes.map(node => {
      // å¦‚æœæ˜¯ç•¶å‰å±¤ç´šçš„ Phaseï¼Œå‰‡å¾äº¤æ›å¾Œçš„ siblingPhases é™£åˆ—ä¸­ç²å–
      if (node.type === "phase" && String(node.containerId) === String(targetPhase.containerId)) {
        const updatedNode = siblingPhases.find(p => p.id === node.id);
        return updatedNode || node;
      }
      // å…¶ä»–ç¯€é»ä¿æŒä¸è®Š
      return node;
    });
  });
};

// ç§»å‹• Taskï¼šåƒ…é‡å°å±¬æ–¼åŒä¸€ Phase (containerId) çš„ Task é€²è¡Œäº¤æ›
const moveTask = (taskId, phaseId, direction) => {
  if (isReadOnly) return;
  setNodes(prevNodes => {
    // åˆ†é›¢å‡ºå±¬æ–¼è©² Phase çš„ Task èˆ‡å…¶ä»–ç¯€é»
    const tasks = prevNodes.filter(n => n.type === "task" && String(n.containerId) === String(phaseId));
    const others = prevNodes.filter(n => !(n.type === "task" && String(n.containerId) === String(phaseId)));
    const index = tasks.findIndex(t => t.id === taskId);
    if (index === -1) return prevNodes;
    const newIndex = index + (direction === "up" ? -1 : 1);
    if (newIndex < 0 || newIndex >= tasks.length) return prevNodes;
    [tasks[index], tasks[newIndex]] = [tasks[newIndex], tasks[index]];
    // å›å‚³æ–°çš„ nodes é™£åˆ—ï¼šç°¡å–®åˆä½µï¼ˆæ­¤æ–¹å¼åƒ…é©ç”¨æ–¼è©² Phase ä¸‹ Task éƒ½æ˜¯é€£çºŒçš„æƒ…æ³ï¼‰
    return [...others, ...tasks];
  });
};

  // åˆ—è¡¨æ¨¡å¼ï¼šä»¥è¡¨æ ¼å‘ˆç¾ Phase èˆ‡ Taskï¼ˆå”¯è®€æ¨¡å¼ä¸‹åƒ…å¯æŸ¥çœ‹èˆ‡è¨­å®š Show in Flowchartï¼‰
  const renderListView = () => {
    // å–å‡ºæœªæŒ‡å®š container çš„ Phase ç¯€é»ï¼ˆé ‚å±¤ Phaseï¼‰
    const topLevelPhases = nodes.filter(n => n.type === "phase" && !n.containerId);
    // å–å‡ºæœªæŒ‡å®š container çš„ Taskï¼ˆå–®ç¨ä»»å‹™ï¼‰
    const unassignedTasks = nodes.filter(n => n.type === "task" && !n.containerId);
    // å…¶ä»–æœªåˆ†é¡çš„å…ƒç´ ï¼ˆéPhase, éTask, ä¸”ç„¡å®¹å™¨ï¼‰
    const unassignedOthers = nodes.filter(n => 
      n.type !== "phase" && n.type !== "task" && 
      n.type !== "arrow" && !n.containerId
    );
  
    // æ›´æ–°ç¯€é»å‡½å¼
    const updateNode = (nodeId, field, value) => {
      if (isReadOnly) return;
      setNodes(prevNodes =>
        prevNodes.map(n => n.id === nodeId ? { ...n, [field]: value } : n)
      );
    };

    // éè¿´æ¸²æŸ“ Phase åŠå…¶å­é …ç›®ï¼ˆå¯åŒ…å« Task å’Œ Phaseï¼‰
    const renderPhaseWithChildren = (phase, indentLevel = 0) => {
      const paddingLeft = indentLevel * 20;
      const bgColor = indentLevel % 2 === 0 ? "#f0f0f0" : "#e8e8e8";
      
      return (
        <React.Fragment key={phase.id}>
          <tr style={{ backgroundColor: bgColor }}>
            <td style={{ paddingLeft: `${paddingLeft}px` }}>
              {/* é»æ“Šç®­é ­å±•é–‹/æ‘ºç–Š */}
              <span onClick={() => toggleCollapse(phase.id)} style={{ cursor: "pointer", marginRight: "5px" }}>
                {collapsedPhases[phase.id] ? "â–½" : "â–³"}
              </span>
              Phase {indentLevel > 0 ? `(å·¢ç‹€å±¤ç´š: ${indentLevel})` : ""}
            </td>
            <td>
              <input
                type="text"
                value={phase.label}
                onChange={(e) => updateNode(phase.id, "label", e.target.value)}
                disabled={isReadOnly}
              />
            </td>
            <td>
              <input
                type="text"
                value={phase.description}
                onChange={(e) => updateNode(phase.id, "description", e.target.value)}
                disabled={isReadOnly}
              />
            </td>
            <td>
              <input
                type="text"
                value={phase.link || ""}
                onChange={(e) => updateNode(phase.id, "link", e.target.value)}
                disabled={isReadOnly}
              />
            </td>
            <td>
              <select
                value={phase.status}
                onChange={(e) => updateNode(phase.id, "status", e.target.value)}
                disabled={isReadOnly}
              >
                <option value="æœªé–‹å§‹">æœªé–‹å§‹</option>
                <option value="è¦åŠƒä¸­">è¦åŠƒä¸­</option>
                <option value="é€²è¡Œä¸­">é€²è¡Œä¸­</option>
                <option value="å·²å®Œæˆ">å·²å®Œæˆ</option>
                <option value="è‡ªè¨‚">è‡ªè¨‚</option>
              </select>
            </td>
            <td>
              {!isReadOnly && (
                <>
                  <button onClick={() => movePhase(phase.id, "up")}>â†‘</button>
                  <button onClick={() => movePhase(phase.id, "down")}>â†“</button>
                </>
              )}
            </td>
            <td>
              <div style={{ display: "flex", flexDirection: "column", gap: "5px" }}>
                <label style={{ display: "flex", alignItems: "center", fontSize: "12px" }}>
                  <input
                    type="checkbox"
                    checked={phase.showInFlowchart !== false}
                    onChange={(e) => updateNode(phase.id, "showInFlowchart", e.target.checked)}
                    disabled={isReadOnly}
                    style={{ marginRight: "5px" }}
                  />
                  æµç¨‹åœ–
                </label>
                <label style={{ display: "flex", alignItems: "center", fontSize: "12px" }}>
                  <input
                    type="checkbox"
                    checked={phase.showForCustomer !== false}
                    onChange={(e) => updateNode(phase.id, "showForCustomer", e.target.checked)}
                    disabled={isReadOnly}
                    style={{ marginRight: "5px" }}
                  />
                  é¡§å®¢å¯è¦‹
                </label>
              </div>
            </td>
          </tr>
          
          {/* è‹¥ Phase æ²’æœ‰æ‘ºç–Šï¼Œå‰‡åˆ—å‡ºå…¶å­é …ç›® */}
          {!collapsedPhases[phase.id] && (
            <>
              {/* å…ˆæ¸²æŸ“è©² Phase åŒ…å«çš„å­ Phase */}
              {nodes
                .filter(n => n.type === "phase" && String(n.containerId) === String(phase.id))
                .map(childPhase => renderPhaseWithChildren(childPhase, indentLevel + 1))
              }
              
              {/* å†æ¸²æŸ“è©² Phase åŒ…å«çš„ Task */}
              {nodes
                .filter(n => n.type === "task" && String(n.containerId) === String(phase.id))
                .map(task => (
                  <tr key={task.id}>
                    <td style={{ paddingLeft: `${paddingLeft + 20}px` }}>Task</td>
                    <td>
                      <input
                        type="text"
                        value={task.label}
                        onChange={(e) => updateNode(task.id, "label", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={task.description}
                        onChange={(e) => updateNode(task.id, "description", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={task.link || ""}
                        onChange={(e) => updateNode(task.id, "link", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <select
                        value={task.status}
                        onChange={(e) => updateNode(task.id, "status", e.target.value)}
                        disabled={isReadOnly}
                      >
                        <option value="æœªé–‹å§‹">æœªé–‹å§‹</option>
                        <option value="è¦åŠƒä¸­">è¦åŠƒä¸­</option>
                        <option value="é€²è¡Œä¸­">é€²è¡Œä¸­</option>
                        <option value="å·²å®Œæˆ">å·²å®Œæˆ</option>
                        <option value="è‡ªè¨‚">è‡ªè¨‚</option>
                      </select>
                    </td>
                    <td>
                      {!isReadOnly && (
                        <>
                          <button onClick={() => moveTask(task.id, phase.id, "up")}>â†‘</button>
                          <button onClick={() => moveTask(task.id, phase.id, "down")}>â†“</button>
                        </>
                      )}
                    </td>
                    <td>
                      <input
                        type="checkbox"
                        checked={task.showInFlowchart !== false}
                        onChange={(e) => updateNode(task.id, "showInFlowchart", e.target.checked)}
                        disabled={isReadOnly}
                      />
                    </td>
                  </tr>
                ))
              }
              
              {/* æœ€å¾Œæ¸²æŸ“å…¶ä»–é¡å‹çš„å­å…ƒç´  (subFlow, iterative, note, extra) */}
              {nodes
                .filter(n => 
                  n.type !== "phase" && n.type !== "task" && n.type !== "arrow" && 
                  String(n.containerId) === String(phase.id)
                )
                .map(otherNode => (
                  <tr key={otherNode.id}>
                    <td style={{ paddingLeft: `${paddingLeft + 20}px` }}>{otherNode.type}</td>
                    <td>
                      <input
                        type="text"
                        value={otherNode.label || ""}
                        onChange={(e) => updateNode(otherNode.id, "label", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={otherNode.description || ""}
                        onChange={(e) => updateNode(otherNode.id, "description", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={otherNode.link || ""}
                        onChange={(e) => updateNode(otherNode.id, "link", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      {otherNode.status ? (
                        <input
                          type="text"
                          value={otherNode.status || ""}
                          onChange={(e) => updateNode(otherNode.id, "status", e.target.value)}
                          disabled={isReadOnly}
                        />
                      ) : <span>-</span>}
                    </td>
                    <td>
                      {/* å…¶ä»–å…ƒç´ æš«ç„¡æ’åºåŠŸèƒ½ */}
                    </td>
                    <td>
                      <input
                        type="checkbox"
                        checked={otherNode.showInFlowchart !== false}
                        onChange={(e) => updateNode(otherNode.id, "showInFlowchart", e.target.checked)}
                        disabled={isReadOnly}
                      />
                    </td>
                  </tr>
                ))
              }
            </>
          )}
        </React.Fragment>
      );
    };
  
    return (
      <div style={{ padding: "20px" }}>
        <h2>Flowchart List View</h2>
        <table border="1" cellPadding="8" style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ backgroundColor: "#ddd" }}>
              <th>Type</th>
              <th>Label</th>
              <th>Description</th>
              <th>Link</th>
              <th>Status</th>
              <th>æ’åº</th>
              <th>é¡¯ç¤ºè¨­å®š</th>
            </tr>
          </thead>
          <tbody>
            {/* æ¸²æŸ“é ‚å±¤ Phase åŠå…¶æ‰€æœ‰å­é …ç›® */}
            {topLevelPhases.map(phase => renderPhaseWithChildren(phase))}
            
            {/* é¡¯ç¤ºæœªæ­¸å±¬æ–¼ä»»ä½• Phase çš„ Task */}
            {unassignedTasks.length > 0 && (
              <>
                <tr>
                  <td colSpan="7" style={{ backgroundColor: "#ccc", fontWeight: "bold" }}>
                    Unassigned Tasks
                  </td>
                </tr>
                {unassignedTasks.map(task => (
                  <tr key={task.id}>
                    <td>Task</td>
                    <td>
                      <input
                        type="text"
                        value={task.label}
                        onChange={(e) => updateNode(task.id, "label", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={task.description}
                        onChange={(e) => updateNode(task.id, "description", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={task.link || ""}
                        onChange={(e) => updateNode(task.id, "link", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <select
                        value={task.status}
                        onChange={(e) => updateNode(task.id, "status", e.target.value)}
                        disabled={isReadOnly}
                      >
                        <option value="æœªé–‹å§‹">æœªé–‹å§‹</option>
                        <option value="è¦åŠƒä¸­">è¦åŠƒä¸­</option>
                        <option value="é€²è¡Œä¸­">é€²è¡Œä¸­</option>
                        <option value="å·²å®Œæˆ">å·²å®Œæˆ</option>
                        <option value="è‡ªè¨‚">è‡ªè¨‚</option>
                      </select>
                    </td>
                    <td>
                      {/* æœªåˆ†é…çš„ Task æš«ç„¡æ’åºåŠŸèƒ½ */}
                    </td>
                    <td>
                      <input
                        type="checkbox"
                        checked={task.showInFlowchart !== false}
                        onChange={(e) => updateNode(task.id, "showInFlowchart", e.target.checked)}
                        disabled={isReadOnly}
                      />
                    </td>
                  </tr>
                ))}
              </>
            )}
            
            {/* é¡¯ç¤ºå…¶ä»–æœªåˆ†é¡çš„å…ƒç´  */}
            {unassignedOthers.length > 0 && (
              <>
                <tr>
                  <td colSpan="7" style={{ backgroundColor: "#ccc", fontWeight: "bold" }}>
                    Other Unassigned Elements
                  </td>
                </tr>
                {unassignedOthers.map(node => (
                  <tr key={node.id}>
                    <td>{node.type}</td>
                    <td>
                      <input
                        type="text"
                        value={node.label || ""}
                        onChange={(e) => updateNode(node.id, "label", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={node.description || ""}
                        onChange={(e) => updateNode(node.id, "description", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        value={node.link || ""}
                        onChange={(e) => updateNode(node.id, "link", e.target.value)}
                        disabled={isReadOnly}
                      />
                    </td>
                    <td>
                      {node.status ? (
                        <input
                          type="text"
                          value={node.status || ""}
                          onChange={(e) => updateNode(node.id, "status", e.target.value)}
                          disabled={isReadOnly}
                        />
                      ) : <span>-</span>}
                    </td>
                    <td>
                      {/* å…¶ä»–å…ƒç´ æš«ç„¡æ’åºåŠŸèƒ½ */}
                    </td>
                    <td>
                      <input
                        type="checkbox"
                        checked={node.showInFlowchart !== false}
                        onChange={(e) => updateNode(node.id, "showInFlowchart", e.target.checked)}
                        disabled={isReadOnly}
                      />
                    </td>
                  </tr>
                ))}
              </>
            )}
          </tbody>
        </table>
      </div>
    );
  };

  // æµç¨‹åœ–æ¨¡å¼ï¼šåªé¡¯ç¤º showInFlowchart ç‚º true çš„ç¯€é»
  const renderFlowchartView = () => (
    <div
      ref={containerRef}
      className="yuniver-flowchart-view"
      style={{
        position: "relative",
        width: "100%",
        height: "600px",
        border: "1px solid #e0e0e0",
        backgroundColor: "#fafafa"
      }}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
    >
{nodes
  .filter(node => node.showInFlowchart !== false)
  .map(node => {
    if (node.type === "arrow") {
      return (
        <div
          key={node.id}
          style={{
            position: "absolute",
            left: node.position.x,
            top: node.position.y,
            width: node.size.width,
            height: node.size.height,
            border: selectedNodeId === node.id ? "2px dashed red" : "0px dashed #999",
            backgroundColor: "transparent",
            cursor: isReadOnly ? "default" : "move",
            zIndex: 1
          }}
          onMouseDown={(e) => handleMouseDown(e, node.id)}
          onClick={(e) => handleSelectNode(e, node.id)}
        >
          {renderArrow(node)}
          
          {/* æ§åˆ¶é» - åƒ…åœ¨é¸ä¸­ç‹€æ…‹ä¸”éå”¯è®€æ¨¡å¼æ™‚é¡¯ç¤º */}
          {!isReadOnly && selectedNodeId === node.id && node.points.map((point, index) => (
            <div
              key={`point-${index}`}
              style={{
                position: "absolute",
                left: point.x - 4,
                top: point.y - 4,
                width: 8,
                height: 8,
                backgroundColor: "blue",
                border: "1px solid white",
                borderRadius: "50%",
                cursor: "pointer",
                zIndex: 20
              }}
              onMouseDown={(e) => handleControlPointMouseDown(e, node.id, index)}
            />
          ))}
          
          {/* æ–°å¢æ§åˆ¶é»æŒ‰éˆ• - åƒ…åœ¨é¸ä¸­ç‹€æ…‹ä¸”éå”¯è®€æ¨¡å¼æ™‚é¡¯ç¤º */}
          {!isReadOnly && selectedNodeId === node.id && (
            <button
              style={{
                position: "absolute",
                right: 0,
                top: -25,
                fontSize: "10px",
                padding: "2px 5px"
              }}
              onClick={(e) => {
                e.stopPropagation();
                handleAddControlPoint(node.id);
              }}
            >
              + Point
            </button>
          )}
          
          {/* ç¸®æ”¾æ§åˆ¶é» */}
          {!isReadOnly && selectedNodeId === node.id && (
            <div
              style={{
                position: "absolute",
                right: 0,
                bottom: 0,
                width: RESIZE_HANDLE_SIZE,
                height: RESIZE_HANDLE_SIZE,
                backgroundColor: "gray",
                cursor: "se-resize"
              }}
              onMouseDown={(e) => handleResizeMouseDown(e, node.id)}
            />
          )}
        </div>
      );
    }
    
    // ç¾æœ‰çš„éç®­é ­ç¯€é»æ¸²æŸ“ä»£ç¢¼...
    // è¨ˆç®— z-index: æ ¹æ“šç¯€é»çš„å·¢ç‹€å±¤ç´šä¾†è¨­å®šï¼Œè¶Šæ·±å±¤çš„ç¯€é» z-index è¶Šé«˜
    const getNodeDepth = (nodeId, depth = 0) => {
      const node = nodes.find(n => n.id === nodeId);
      if (!node || !node.containerId) return depth;
      return getNodeDepth(node.containerId, depth + 1);
    };
    
    // è¨ˆç®—æ­£ç¢ºçš„ z-index: phase æ¯” task é«˜ï¼ŒåŒæ™‚è€ƒæ…®å·¢ç‹€æ·±åº¦
    const nodeDepth = getNodeDepth(node.id);
    const baseZIndex = node.type === "phase" ? 100 : (node.type === "task" ? 50 : 10);
    const zIndex = baseZIndex + nodeDepth * 10;
    return (
      <div
        key={node.id}
        style={{
          position: "absolute",
          left: node.position.x,
          top: node.position.y,
          width: node.size.width,
          height: node.size.height,
          border: selectedNodeId === node.id ? "2px solid red" : "1px solid #333",
          boxSizing: "border-box",
          backgroundColor:
            (node.type === "phase" || node.type === "task")
              ? getStatusColor(node)
              : "#fff",
          cursor: isReadOnly ? "default" : "move",
          zIndex,
          ...getShapeStyle(node.shape)
        }}
        onMouseDown={(e) => handleMouseDown(e, node.id)}
        onClick={(e) => handleSelectNode(e, node.id)}
      >
        {renderNodeContent(node)}
        {!isReadOnly && selectedNodeId === node.id && (
          <div
            style={{
              position: "absolute",
              right: 0,
              bottom: 0,
              width: RESIZE_HANDLE_SIZE,
              height: RESIZE_HANDLE_SIZE,
              backgroundColor: "gray",
              cursor: "se-resize"
            }}
            onMouseDown={(e) => handleResizeMouseDown(e, node.id)}
          />
        )}
      </div>
    );
  })}
    </div>
  );

  return (
    <div className="yuniver-container">
      <header className="yuniver-header">
        <div className="yuniver-logo">
          <h1>YUNIVER <span className="registered-mark">Â®</span></h1>
          <p className="subtitle">æ¡ˆä»¶é€²åº¦æµç¨‹åœ–</p>
        </div>
      </header>

      <div className="yuniver-content">
        <div className="main-content">          
          <div className="yuniver-flowchart-container">
            <div className="yuniver-flowchart-header">
              {renderHeader()}
            </div>
            
            <div className="yuniver-flowchart-content">
              {displayMode === "flowchart" ? renderFlowchartView() : renderListView()}
            </div>
          </div>
          
          {!isReadOnly && selectedNode && (
            <div className="yuniver-flowchart-container">
              <div className="yuniver-flowchart-header">
                <h3 className="yuniver-flowchart-title">Edit Node Properties</h3>
              </div>
              
              <div className="yuniver-flowchart-content">
                <div className="yuniver-node yuniver-node-properties">
                  <div>
                    <label>Type:</label>
                    <select name="type" value={selectedNode.type} onChange={handleEditChange} className="form-control">
                      <option value="phase">phase</option>
                      <option value="task">task</option>
                      <option value="subFlow">subFlow</option>
                      <option value="iterative">iterative</option>
                      <option value="note">note</option>
                      <option value="extra">extra</option>
                    </select>
                  </div>
                  <div>
                    <label>Label:</label>
                    <input name="label" value={selectedNode.label} onChange={handleEditChange} className="form-control" />
                  </div>
                  <div>
                    <label>Description:</label>
                    <textarea name="description" value={selectedNode.description} onChange={handleEditChange} className="form-control" />
                  </div>
                  <div>
                    <label>Link:</label>
                    <input name="link" value={selectedNode.link} onChange={handleEditChange} className="form-control" />
                  </div>
                  {(selectedNode.type === "phase" || selectedNode.type === "task") && (
                    <div>
                      <label>Status:</label>
                      <select name="status" value={selectedNode.status} onChange={handleEditChange} className="form-control">
                        <option value="æœªé–‹å§‹">æœªé–‹å§‹</option>
                        <option value="è¦åŠƒä¸­">è¦åŠƒä¸­</option>
                        <option value="é€²è¡Œä¸­">é€²è¡Œä¸­</option>
                        <option value="å·²å®Œæˆ">å·²å®Œæˆ</option>
                        <option value="è‡ªè¨‚">è‡ªè¨‚</option>
                      </select>
                      {selectedNode.status === "è‡ªè¨‚" && (
                        <div>
                          <label>Custom Status:</label>
                          <input name="customStatus" value={selectedNode.customStatus || ""} onChange={handleEditChange} className="form-control" />
                        </div>
                      )}
                      <div>
                        <label>Shape:</label>
                        <select name="shape" value={selectedNode.shape} onChange={handleEditChange} className="form-control">
                          <option value="rectangle">çŸ©å½¢</option>
                          <option value="ellipse">æ©¢åœ“ / è—¥ä¸¸</option>
                          <option value="parallelogram">å¹³è¡Œå››é‚Šå½¢</option>
                          <option value="diamond">è±å½¢</option>
                        </select>
                      </div>
                    </div>
                  )}
                  <div>
                    <label>Children (comma-separated IDs):</label>
                    <input
                      value={(selectedNode.children || []).join(",")}
                      onChange={handleChildrenChange}
                      className="form-control"
                    />
                  </div>
                  <div>
                    <label>Extras (comma-separated):</label>
                    <input
                      name="extras"
                      value={(selectedNode.extras || []).join(",")}
                      onChange={(e) => {
                        const arr = e.target.value.split(",").map(s => s.trim()).filter(s => s);
                        handleEditChange({ target: { name: "extras", value: arr } });
                      }}
                      className="form-control"
                    />
                  </div>
                  <div style={{ marginTop: "10px", display: "flex", alignItems: "center", gap: "10px" }}>
                    <label style={{ marginBottom: "0" }}>
                      <input
                        type="checkbox"
                        name="showInFlowchart"
                        checked={selectedNode.showInFlowchart !== false}
                        onChange={(e) => handleEditChange({ 
                          target: { name: "showInFlowchart", value: e.target.checked } 
                        })}
                      />
                      {" "} Show in Flowchart
                    </label>
                    <label style={{ marginBottom: "0" }}>
                      <input
                        type="checkbox"
                        name="showForCustomer"
                        checked={selectedNode.showForCustomer !== false}
                        onChange={(e) => handleEditChange({ 
                          target: { name: "showForCustomer", value: e.target.checked } 
                        })}
                      />
                      {" "} Show for Customer
                    </label>
                  </div>
                  <div style={{ marginTop: "10px" }}>
                    <button onClick={handleDeleteNode} className="yuniver-btn danger">Delete Node</button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default CustomFlowChartEditor;
